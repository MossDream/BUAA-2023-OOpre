# 第二次作业指导书

在本次作业中，我们即将完成面向对象先导课程作业的基础代码编写，在以后的作业中，我们将在本次作业的基础上进行迭代开发。

## 第一部分：提交要求

请保证提交项目的顶层目录至少存在两个文件夹：`src`和`test`（命名需严格与此保持一致），请将作业的**功能代码**存放于`src`文件夹下，同时将相关**junit测试类代码**文件存放于`test`文件夹下，以保证评测的正常进行（评测时**只会**针对`src`目录下的文件进行程序**功能**的评测以及代码风格检测，也就是说，`test`目录下的junit测试代码风格不会被检测）。参考目录结构如下：

```
|-src
  |- Bottle.java
  |- Equipment.java
  |- ...
|-test
  |- BottleTest.java
  |- EquipmentTest.java
  |- ...
```
## 第二部分：题目描述

### 背景

在接下来的若干次作业中，同学们将进行以本次作业为基础的迭代开发，因此在具体的代码实现中，希望同学们可以考虑到每一次所写代码的可扩展性和可维护性，从而减少下一次的工作量。

在接下来的几次作业中，请想象你是一个穿越到魔法大陆上的冒险者，在旅途中，你需要收集各种道具，使用各种装备，招募其他冒险者加入队伍，提升自己的等级并体验各种战斗。


在本次作业中，你要做的是：

- 实现冒险者类 `Adventurer` 、药水瓶类 `Bottle` 、装备类 `Equipment`

- 利用容器，管理所有冒险者，并管理每一个冒险者所拥有的药水瓶和装备

  


你可能需要实现的类和它们要拥有的属性

- Adventure ：ID，名字，药水瓶和装备各自的容器
- Bottle：ID，名字，容量(capacity)
- Equipment：ID，名字，星级(star)

**请注意，在作业中，可能会存在ID不同但名字相同的情况，请同学们在设计代码的时候考虑这一点**

其中，Bottle的容量属性在本次作业中不会被测试，但是却是后续作业的重要部分，请同学们不要忽略。

在本次作业中，初始时，你没有需要管理的冒险者，我们通过若干条操作指令来修改当前的状态：

1. 加入一个需要管理的冒险者（新加入的冒险者不携带任何药水瓶和装备）

2. 给某个冒险者增加一个药水瓶

3. 删除某个冒险者的某个药水瓶

4. 给某个冒险者增加一个装备

5. 删除某个冒险者的某个装备

6. 给某个冒险者的某个装备提升一个星级

   

其中，提升星级的意思是，新星级=原有星级+1

### 输入格式

第一行一个整数 *n*，表示操作的个数。

接下来的 n 行，每行一个形如 `{type} {attribute}` 的操作，`{type}` 和 `{attribute}` 间、若干个 `{attribute}` 间使用**若干**个空格分割，操作输入形式及其含义如下。同时，为了方便测评，我们需要在需要执行一些指令后进行相关输出。具体要求也在下面的表中列出：

| type | attribute                             | 意义                                                         | 输出格式（每条对应的占一行）                                 |
| ---- | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | `{adv_id} {name}`                     | 加入一个 ID 为 `{adv_id}`、名字为 `{name}` 的冒险者          | 无                                                           |
| 2    | `{adv_id} {bot_id} {name} {capacity}` | 给 ID 为 `{adv_id}` 的冒险者增加一个药水瓶，药水瓶的 ID、名字、容量分别为 `{bot_id}`、`{name}`、`{capacity}` | 无                                                           |
| 3    | `{adv_id} {bot_id}`                   | 将 ID 为 `{adv_id}` 的冒险者的 id 为 `{bot_id}` 的药水瓶删除 | `{一个整数} {一个字符串}`（解释：整数为删除后冒险者药水瓶数目，字符串为删除的药水瓶的name） |
| 4    | `{adv_id} {equ_id} {name} {star}`     | 给 ID 为 `{adv_id}` 的冒险者增加一个装备，装备的 ID、名字、星级分别为 `{equ_id}`、`{name}`、`{star}` | 无                                                           |
| 5    | `{adv_id} {equ_id}`                   | 将 ID 为 `{adv_id}` 的冒险者的 id 为 `{equ_id}` 的装备删除   | `{一个整数} {一个字符串}`（解释：整数为删除后冒险者装备数目，字符串为删除的装备的name） |
| 6    | `{adv_id} {equ_id}`                   | 将 ID 为 `{adv_id}` 的冒险者的 id 为 `{equ_id}` 的装备提升一个星级 | `{一个字符串} {一个整数}`（解释：字符串为装备的name，整数为装备升星后的星级） |

输出数值时，你的输出数值需要和正确数值相等。

#### 输入输出样例

##### 输入1

```
4
1 700917 i$KdS=1n
4 700917 829431 ?TE/G1 3 
6 700917 829431
5 700917 829431
```

##### 输出1

```
?TE/G1 4
0 ?TE/G1
```

##### 输入2

```
3
1 700917 i$KdS=1n
2 700917 829431 ?TE/G1 3 
3 700917 829431
```

##### 输出2

```
0 ?TE/G1
```

### 数据限制

##### 变量约束

| 变量       | 类型   | 说明                                   |
| ---------- | ------ | -------------------------------------- |
| `id `      | 整数   | 取值范围：0 - 2147483647               |
| `name`     | 字符串 | 保证不会出现空白字符，长度区间: (0,40) |
| `capacity` | 整数   | 取值范围：0 - 2147483647               |
| `star`     | 整数   | 取值范围：0 - 2147483647               |

##### 操作约束

1. **保证所有的冒险者、药水瓶、装备 id 均不相同**
2. 保证删除了的药水瓶/装备的 id 不会再次出现
3. 2-6保证所有冒险者均已存在
4. 3/5/6保证该冒险者拥有操作中提到 id 的药水瓶/装备
5. 保证增加的装备和药水瓶原本不存在
6. 操作数满足1≤*n*≤2000

### junit测试

我们在gitlab上准备了一份**junit使用示例代码**（基于hw1程序）以及一份**junit使用文档**供大家参考，推荐各位同学在课下测试时使用 junit 单元测试来对自己的程序进行测试

- junit 是一个单元测试包，**可以通过编写单元测试类和方法，来实现对类和方法实现正确性的快速检查和测试**。还可以查看测试覆盖率以及具体覆盖范围（精确到语句级别），以帮助编程者全面无死角地进行程序功能测试。

- 此外，Junit 对主流 Java IDE（Idea、eclipse 等）均有较为完善的支持，具体的配置和使用方法可以参考gitlab上的使用文档。

#### 要求

本次作业要求同学们需要自行编写junit测试代码对自己的代码进行测试。在本次作业中，检测到**存在junit测试方法**并可以**成功编译**即视为通过junit评测。

### 提示

考虑到正课尚未讲解有关输入解析的内容，我们在此提供一份输入解析代码，同学们可以将其复制到自己代码中的适当位置直接使用，当然，同学们也可以自行设计代码来进行输入解析。

```java
ArrayList<ArrayList<String>> inputInfo = new ArrayList<>(); // 解析后的输入将会存进该容器中, 类似于c语言的二维数组
Scanner scanner = new Scanner(System.in);
int n = Integer.parseInt(scanner.nextLine().trim()); // 读取行数
for (int i = 0; i < n; ++i) {
    String nextLine = scanner.nextLine(); // 读取本行指令
    String[] strings = nextLine.trim().split(" +"); // 按空格对行进行分割
    inputInfo.add(new ArrayList<>(Arrays.asList(strings))); // 将指令分割后的各个部分存进容器中
}
```

经过这段代码，输入的信息会按照顺序被存入`inputInfo`这个"二维数组"中，遍历该容器即可取出各行指令及其各个部分。

